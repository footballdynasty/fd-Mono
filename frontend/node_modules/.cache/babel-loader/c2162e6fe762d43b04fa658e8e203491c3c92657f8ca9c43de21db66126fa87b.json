{"ast":null,"code":"import { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n  return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(elementOrSelector, onPressStart) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\n  const startPress = startEvent => {\n    const element = startEvent.currentTarget;\n    if (!isValidPressEvent(startEvent) || isPressing.has(element)) return;\n    isPressing.add(element);\n    const onPressEnd = onPressStart(startEvent);\n    const onPointerEnd = (endEvent, success) => {\n      window.removeEventListener(\"pointerup\", onPointerUp);\n      window.removeEventListener(\"pointercancel\", onPointerCancel);\n      if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\n        return;\n      }\n      isPressing.delete(element);\n      if (typeof onPressEnd === \"function\") {\n        onPressEnd(endEvent, {\n          success\n        });\n      }\n    };\n    const onPointerUp = upEvent => {\n      onPointerEnd(upEvent, options.useGlobalTarget || isNodeOrChild(element, upEvent.target));\n    };\n    const onPointerCancel = cancelEvent => {\n      onPointerEnd(cancelEvent, false);\n    };\n    window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n    window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n  };\n  elements.forEach(element => {\n    if (!isElementKeyboardAccessible(element) && element.getAttribute(\"tabindex\") === null) {\n      element.tabIndex = 0;\n    }\n    const target = options.useGlobalTarget ? window : element;\n    target.addEventListener(\"pointerdown\", startPress, eventOptions);\n    element.addEventListener(\"focus\", event => enableKeyboardPress(event, eventOptions), eventOptions);\n  });\n  return cancelEvents;\n}\nexport { press };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}