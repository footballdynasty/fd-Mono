{"ast":null,"code":"import _objectSpread from \"/Users/brodycritchlow/Projects/footballdynasty-new/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/brodycritchlow/Projects/footballdynasty-new/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"axis\"];\nimport { supportsScrollTimeline } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { observeTimeline } from './observe.mjs';\nimport { scrollInfo } from './track.mjs';\nfunction scrollTimelineFallback(_ref) {\n  let {\n    source,\n    container,\n    axis = \"y\"\n  } = _ref;\n  // Support legacy source argument. Deprecate later.\n  if (source) container = source;\n  // ScrollTimeline records progress as a percentage CSSUnitValue\n  const currentTime = {\n    value: 0\n  };\n  const cancel = scrollInfo(info => {\n    currentTime.value = info[axis].progress * 100;\n  }, {\n    container,\n    axis\n  });\n  return {\n    currentTime,\n    cancel\n  };\n}\nconst timelineCache = new Map();\nfunction getTimeline() {\n  let {\n    source,\n    container = document.documentElement,\n    axis = \"y\"\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Support legacy source argument. Deprecate later.\n  if (source) container = source;\n  if (!timelineCache.has(container)) {\n    timelineCache.set(container, {});\n  }\n  const elementCache = timelineCache.get(container);\n  if (!elementCache[axis]) {\n    elementCache[axis] = supportsScrollTimeline() ? new ScrollTimeline({\n      source: container,\n      axis\n    }) : scrollTimelineFallback({\n      source: container,\n      axis\n    });\n  }\n  return elementCache[axis];\n}\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n  return onScroll.length === 2;\n}\n/**\n * Currently, we only support element tracking with `scrollInfo`, though in\n * the future we can also offer ViewTimeline support.\n */\nfunction needsElementTracking(options) {\n  return options && (options.target || options.offset);\n}\nfunction scrollFunction(onScroll, options) {\n  if (isOnScrollWithInfo(onScroll) || needsElementTracking(options)) {\n    return scrollInfo(info => {\n      onScroll(info[options.axis].progress, info);\n    }, options);\n  } else {\n    return observeTimeline(onScroll, getTimeline(options));\n  }\n}\nfunction scrollAnimation(animation, options) {\n  animation.flatten();\n  if (needsElementTracking(options)) {\n    animation.pause();\n    return scrollInfo(info => {\n      animation.time = animation.duration * info[options.axis].progress;\n    }, options);\n  } else {\n    const timeline = getTimeline(options);\n    if (animation.attachTimeline) {\n      return animation.attachTimeline(timeline, valueAnimation => {\n        valueAnimation.pause();\n        return observeTimeline(progress => {\n          valueAnimation.time = valueAnimation.duration * progress;\n        }, timeline);\n      });\n    } else {\n      return noop;\n    }\n  }\n}\nfunction scroll(onScroll) {\n  let _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    {\n      axis = \"y\"\n    } = _ref2,\n    options = _objectWithoutProperties(_ref2, _excluded);\n  const optionsWithDefaults = _objectSpread({\n    axis\n  }, options);\n  return typeof onScroll === \"function\" ? scrollFunction(onScroll, optionsWithDefaults) : scrollAnimation(onScroll, optionsWithDefaults);\n}\nexport { scroll };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}